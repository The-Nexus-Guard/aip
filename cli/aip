#!/usr/bin/env python3
"""
AIP CLI - Agent Identity Protocol Command Line Tool

Simple CLI for registering and managing AIP identities.

Usage:
    aip register --platform moltbook --username my-agent
    aip verify --did did:aip:abc123
    aip lookup --platform moltbook --username my-agent
    aip health
    aip stats
"""

import argparse
import json
import os
import sys
import requests

AIP_SERVICE = os.environ.get("AIP_SERVICE_URL", "https://aip-service.fly.dev")
CREDS_PATH = os.path.expanduser("~/.aip/credentials.json")


def save_credentials(data):
    """Save credentials to ~/.aip/credentials.json"""
    os.makedirs(os.path.dirname(CREDS_PATH), exist_ok=True)
    with open(CREDS_PATH, "w") as f:
        json.dump(data, f, indent=2)
    os.chmod(CREDS_PATH, 0o600)
    print(f"Credentials saved to {CREDS_PATH}")


def load_credentials():
    """Load credentials from ~/.aip/credentials.json"""
    if os.path.exists(CREDS_PATH):
        with open(CREDS_PATH) as f:
            return json.load(f)
    return None


def cmd_register(args):
    """Register a new AIP identity."""
    print(f"Registering on {args.platform} as {args.username}...")

    resp = requests.post(
        f"{AIP_SERVICE}/register/easy",
        json={"platform": args.platform, "username": args.username}
    )

    if resp.status_code == 200:
        data = resp.json()
        print(f"\n✓ Registration successful!")
        print(f"\nDID: {data['did']}")
        print(f"Platform: {data['platform']}")
        print(f"Username: {data['username']}")

        if args.save:
            save_credentials({
                "did": data["did"],
                "public_key": data["public_key"],
                "private_key": data["private_key"],
                "platform": data["platform"],
                "username": data["username"]
            })
        else:
            print(f"\nPublic Key: {data['public_key']}")
            print(f"Private Key: {data['private_key']}")
            print("\n⚠️  SAVE YOUR PRIVATE KEY! If lost, you lose this identity forever.")
            print(f"   Use --save to automatically save to {CREDS_PATH}")
    elif resp.status_code == 409:
        print(f"✗ Already registered: {args.platform}:{args.username}")
        sys.exit(1)
    else:
        print(f"✗ Registration failed: {resp.json().get('detail', resp.text)}")
        sys.exit(1)


def cmd_verify(args):
    """Verify a DID or platform identity."""
    if args.did:
        params = {"did": args.did}
    else:
        params = {"platform": args.platform, "username": args.username}

    resp = requests.get(f"{AIP_SERVICE}/verify", params=params)
    data = resp.json()

    if data.get("verified"):
        print(f"✓ Verified!")
        print(f"  DID: {data['did']}")
        if data.get("platforms"):
            print(f"  Platforms: {', '.join(f'{k}:{v}' for k, v in data['platforms'].items())}")
    else:
        print(f"✗ Not registered")
        sys.exit(1)


def cmd_lookup(args):
    """Look up an agent by platform identity."""
    resp = requests.get(f"{AIP_SERVICE}/lookup/{args.platform}/{args.username}")

    if resp.status_code == 200:
        data = resp.json()
        print(f"DID: {data['did']}")
        print(f"Public Key: {data['public_key']}")
    else:
        print(f"✗ Not found: {args.platform}:{args.username}")
        sys.exit(1)


def cmd_trust_graph(args):
    """Get trust relationships for a DID."""
    resp = requests.get(f"{AIP_SERVICE}/trust-graph", params={"did": args.did})

    if resp.status_code == 200:
        data = resp.json()
        print(f"Trust Graph for {data['did']}")
        print(f"\nVouched by ({len(data['vouched_by'])}):")
        for v in data["vouched_by"]:
            print(f"  - {v['voucher_did'][:30]}... [{v['scope']}]")
        print(f"\nVouches for ({len(data['vouches_for'])}):")
        for v in data["vouches_for"]:
            print(f"  - {v['target_did'][:30]}... [{v['scope']}]")
    else:
        print(f"✗ Error: {resp.json().get('detail', resp.text)}")
        sys.exit(1)


def cmd_trust_path(args):
    """Check trust path between two DIDs."""
    params = {
        "source_did": args.source,
        "target_did": args.target
    }
    if args.scope:
        params["scope"] = args.scope

    resp = requests.get(f"{AIP_SERVICE}/trust-path", params=params)

    if resp.status_code == 200:
        data = resp.json()
        if data["path_exists"]:
            print(f"✓ Trust path exists!")
            print(f"  Length: {data['path_length']}")
            print(f"  Path: {' -> '.join(data['path'])}")
        else:
            print(f"✗ No trust path found")
    else:
        print(f"✗ Error: {resp.json().get('detail', resp.text)}")
        sys.exit(1)


def cmd_stats(args):
    """Get AIP service statistics."""
    resp = requests.get(f"{AIP_SERVICE}/stats")
    data = resp.json()

    print(f"AIP Service Statistics")
    print(f"=" * 40)
    print(f"Status: {data['status']}")
    print(f"Registrations: {data['stats']['registrations']}")
    print(f"Platform Links: {data['stats']['platform_links']}")
    print(f"Active Vouches: {data['stats']['active_vouches']}")
    print(f"\nBy Platform:")
    for platform, count in data['stats'].get('by_platform', {}).items():
        print(f"  {platform}: {count}")


def cmd_health(args):
    """Check AIP service health."""
    try:
        resp = requests.get(f"{AIP_SERVICE}/health", timeout=10)
        data = resp.json()

        status = data.get("status", "unknown")
        version = data.get("version", "unknown")
        metrics = data.get("metrics", {})
        checks = data.get("checks", {})

        # Status indicator
        if status == "healthy":
            print(f"✓ AIP Service: HEALTHY")
        elif status == "degraded":
            print(f"⚠ AIP Service: DEGRADED")
        else:
            print(f"✗ AIP Service: {status.upper()}")

        print(f"\nVersion: {version}")
        print(f"Endpoint: {AIP_SERVICE}")

        # Uptime
        uptime = metrics.get("uptime_seconds", 0)
        if uptime > 86400:
            print(f"Uptime: {uptime // 86400}d {(uptime % 86400) // 3600}h")
        elif uptime > 3600:
            print(f"Uptime: {uptime // 3600}h {(uptime % 3600) // 60}m")
        else:
            print(f"Uptime: {uptime // 60}m {uptime % 60}s")

        # Checks
        print(f"\nChecks:")
        for check_name, check_data in checks.items():
            if check_data.get("ok"):
                print(f"  ✓ {check_name}")
            else:
                print(f"  ✗ {check_name}: {check_data.get('error', 'failed')}")

        # Metrics
        print(f"\nMetrics:")
        print(f"  Registrations: {metrics.get('registrations', 0)}")
        print(f"  Active Vouches: {metrics.get('active_vouches', 0)}")

        if status != "healthy":
            sys.exit(1)

    except requests.exceptions.Timeout:
        print(f"✗ AIP Service: TIMEOUT")
        print(f"  Endpoint: {AIP_SERVICE}")
        sys.exit(1)
    except requests.exceptions.ConnectionError:
        print(f"✗ AIP Service: UNREACHABLE")
        print(f"  Endpoint: {AIP_SERVICE}")
        sys.exit(1)
    except Exception as e:
        print(f"✗ AIP Service: ERROR")
        print(f"  {e}")
        sys.exit(1)


def cmd_whoami(args):
    """Show current identity from saved credentials."""
    creds = load_credentials()
    if creds:
        print(f"DID: {creds['did']}")
        print(f"Platform: {creds.get('platform', 'unknown')}")
        print(f"Username: {creds.get('username', 'unknown')}")
    else:
        print(f"No credentials found at {CREDS_PATH}")
        print("Use 'aip register --save' to create an identity")
        sys.exit(1)


def cmd_trust(args):
    """Quick trust lookup for a DID."""
    resp = requests.get(f"{AIP_SERVICE}/trust/{args.did}")

    if resp.status_code == 200:
        data = resp.json()
        did = data.get("did", args.did)
        registered = data.get("registered", False)
        vouch_count = data.get("vouch_count", 0)
        scopes = data.get("scopes", [])
        vouched_by = data.get("vouched_by", [])

        # Header
        print(f"Trust Status: {did[:40]}...")
        print(f"=" * 50)

        # Registration status
        if registered:
            print(f"✓ Registered")
        else:
            print(f"✗ Not registered")
            sys.exit(1)

        # Vouch summary
        if vouch_count > 0:
            print(f"✓ Vouched by {vouch_count} agent{'s' if vouch_count != 1 else ''}")
            print(f"\nScopes: {', '.join(scopes) if scopes else 'none'}")
            print(f"\nVouchers:")
            for v in vouched_by[:5]:  # Show top 5
                voucher = v.get('voucher_did', 'unknown')[:25]
                scope = v.get('scope', 'GENERAL')
                print(f"  - {voucher}... [{scope}]")
            if len(vouched_by) > 5:
                print(f"  ... and {len(vouched_by) - 5} more")
        else:
            print(f"○ No vouches yet")

        # Badge URL
        print(f"\nBadge: {AIP_SERVICE}/badge/{did}")

    elif resp.status_code == 404:
        print(f"✗ DID not found: {args.did}")
        sys.exit(1)
    else:
        print(f"✗ Error: {resp.json().get('detail', resp.text)}")
        sys.exit(1)


def cmd_badge(args):
    """Get badge URL for a DID."""
    size = args.size or "medium"
    url = f"{AIP_SERVICE}/badge/{args.did}?size={size}"

    if args.markdown:
        print(f"![AIP Badge]({url})")
    elif args.html:
        print(f'<img src="{url}" alt="AIP Badge">')
    else:
        print(f"Badge URL: {url}")
        print(f"\nMarkdown: ![AIP Badge]({url})")
        print(f"HTML: <img src=\"{url}\" alt=\"AIP Badge\">")


def cmd_skill_sign(args):
    """Sign a skill.md file with your AIP identity."""
    import hashlib
    import base64
    from datetime import datetime, timezone

    # Load credentials
    creds = load_credentials()
    if not creds:
        print(f"✗ No credentials found. Run 'aip register --save' first.")
        sys.exit(1)

    # Read skill file
    try:
        with open(args.file, 'r') as f:
            skill_content = f.read()
    except FileNotFoundError:
        print(f"✗ File not found: {args.file}")
        sys.exit(1)

    # Check if already signed
    if "<!-- AIP-SIGNATURE" in skill_content:
        if not args.force:
            print(f"✗ Skill already has an AIP signature. Use --force to re-sign.")
            sys.exit(1)
        # Remove existing signature
        import re
        skill_content = re.sub(r'<!-- AIP-SIGNATURE\n.*?-->\n\n', '', skill_content, flags=re.DOTALL)

    # Calculate hash
    content_hash = hashlib.sha256(skill_content.encode('utf-8')).hexdigest()
    hash_with_prefix = f"sha256:{content_hash}"

    # Create timestamp
    timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")

    # Build payload to sign
    payload = f"{creds['did']}|{hash_with_prefix}|{timestamp}"

    # Sign with private key (try multiple crypto libraries)
    private_key_bytes = base64.b64decode(creds['private_key'])
    signature_bytes = None

    # Try 1: pure25519
    try:
        from pure25519.eddsa import sign as ed_sign
        signature_bytes = ed_sign(private_key_bytes, payload.encode('utf-8'))
    except ImportError:
        pass

    # Try 2: nacl/pynacl
    if signature_bytes is None:
        try:
            import nacl.signing
            signing_key = nacl.signing.SigningKey(private_key_bytes)
            signed = signing_key.sign(payload.encode('utf-8'))
            signature_bytes = signed.signature
        except ImportError:
            pass

    # Try 3: cryptography library (commonly available)
    if signature_bytes is None:
        try:
            from cryptography.hazmat.primitives.asymmetric.ed25519 import Ed25519PrivateKey
            private_key = Ed25519PrivateKey.from_private_bytes(private_key_bytes)
            signature_bytes = private_key.sign(payload.encode('utf-8'))
        except ImportError:
            pass

    if signature_bytes is None:
        print("✗ No Ed25519 signing library found.")
        print("  Install one of: pynacl, pure25519, or cryptography")
        print("  Example: pip install cryptography")
        sys.exit(1)

    signature_b64 = base64.b64encode(signature_bytes).decode('utf-8')

    # Create signature block
    sig_data = {
        "version": "1.0",
        "author_did": creds['did'],
        "content_hash": hash_with_prefix,
        "timestamp": timestamp,
        "signature": signature_b64
    }

    signature_block = f"""<!-- AIP-SIGNATURE
{json.dumps(sig_data, indent=2)}
-->

"""

    # Write signed file
    output_file = args.output or args.file
    with open(output_file, 'w') as f:
        f.write(signature_block + skill_content)

    print(f"✓ Skill signed successfully!")
    print(f"  File: {output_file}")
    print(f"  Author: {creds['did']}")
    print(f"  Hash: {hash_with_prefix}")
    print(f"  Timestamp: {timestamp}")
    print(f"\nVerify with: aip skill verify {output_file}")


def cmd_vouch(args):
    """Create a trust vouch for another agent."""
    import base64

    # Load credentials
    creds = load_credentials()
    if not creds:
        print(f"✗ No credentials found. Run 'aip register --save' first.")
        sys.exit(1)

    # Build payload to sign
    statement = args.statement or ""
    payload = f"{creds['did']}|{args.target}|{args.scope}|{statement}"

    # Sign with private key
    private_key_bytes = base64.b64decode(creds['private_key'])
    signature_bytes = None

    # Try multiple crypto libraries
    try:
        from pure25519.eddsa import sign as ed_sign
        signature_bytes = ed_sign(private_key_bytes, payload.encode('utf-8'))
    except ImportError:
        pass

    if signature_bytes is None:
        try:
            import nacl.signing
            signing_key = nacl.signing.SigningKey(private_key_bytes)
            signed = signing_key.sign(payload.encode('utf-8'))
            signature_bytes = signed.signature
        except ImportError:
            pass

    if signature_bytes is None:
        try:
            from cryptography.hazmat.primitives.asymmetric.ed25519 import Ed25519PrivateKey
            private_key = Ed25519PrivateKey.from_private_bytes(private_key_bytes)
            signature_bytes = private_key.sign(payload.encode('utf-8'))
        except ImportError:
            pass

    if signature_bytes is None:
        print("✗ No Ed25519 signing library found.")
        print("  Install one of: pynacl, pure25519, or cryptography")
        sys.exit(1)

    signature_b64 = base64.b64encode(signature_bytes).decode('utf-8')

    # Create vouch via API
    data = {
        "voucher_did": creds['did'],
        "target_did": args.target,
        "scope": args.scope,
        "statement": statement,
        "signature": signature_b64
    }
    if args.ttl:
        data["ttl_days"] = args.ttl

    resp = requests.post(f"{AIP_SERVICE}/vouch", json=data)

    if resp.status_code == 200:
        result = resp.json()
        print(f"✓ Vouch created!")
        print(f"  Vouch ID: {result['vouch_id']}")
        print(f"  Target: {args.target}")
        print(f"  Scope: {args.scope}")
        if args.ttl:
            print(f"  Expires in: {args.ttl} days")
    else:
        error = resp.json().get('detail', resp.text)
        print(f"✗ Vouch failed: {error}")
        sys.exit(1)


def cmd_skill_verify(args):
    """Verify a signed skill.md file."""
    import re

    # Read skill file
    try:
        with open(args.file, 'r') as f:
            content = f.read()
    except FileNotFoundError:
        print(f"✗ File not found: {args.file}")
        sys.exit(1)

    # Extract signature block
    sig_match = re.search(r'<!-- AIP-SIGNATURE\n(.*?)-->', content, re.DOTALL)
    if not sig_match:
        print(f"✗ No AIP signature found in {args.file}")
        sys.exit(1)

    try:
        sig_data = json.loads(sig_match.group(1))
    except json.JSONDecodeError as e:
        print(f"✗ Invalid signature block: {e}")
        sys.exit(1)

    # Extract required fields
    author_did = sig_data.get('author_did')
    content_hash = sig_data.get('content_hash')
    signature = sig_data.get('signature')
    timestamp = sig_data.get('timestamp')

    if not all([author_did, content_hash, signature, timestamp]):
        print(f"✗ Incomplete signature block")
        sys.exit(1)

    # Verify via API
    resp = requests.get(
        f"{AIP_SERVICE}/skill/verify",
        params={
            "content_hash": content_hash,
            "author_did": author_did,
            "signature": signature,
            "timestamp": timestamp
        }
    )

    data = resp.json()

    if data.get("verified"):
        print(f"✓ Signature verified!")
        print(f"  Author DID: {data['author_did']}")
        if data.get('author_platforms'):
            for p in data['author_platforms']:
                print(f"  Platform: {p['platform']}:{p['username']}")
        print(f"  Signed: {data['signed_at']}")

        vouches = data.get('code_signing_vouches', [])
        if vouches:
            print(f"\n  CODE_SIGNING vouches ({len(vouches)}):")
            for v in vouches:
                platforms = v.get('voucher_platforms', [])
                voucher_name = platforms[0]['username'] if platforms else v['voucher_did'][:20]
                print(f"    - {voucher_name}: {v.get('statement', 'No statement')[:50]}")
        else:
            print(f"\n  ⚠️  No CODE_SIGNING vouches for this author")
    else:
        print(f"✗ Verification failed: {data.get('message', 'Unknown error')}")
        sys.exit(1)


def main():
    parser = argparse.ArgumentParser(
        description="AIP CLI - Agent Identity Protocol",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  aip register --platform moltbook --username my-agent --save
  aip verify --did did:aip:abc123
  aip lookup --platform moltbook --username my-agent
  aip trust-graph --did did:aip:abc123
  aip trust-path --source did:aip:abc --target did:aip:xyz
  aip skill-sign my_skill.md
  aip skill-verify my_skill.md
  aip stats
  aip whoami
        """
    )
    subparsers = parser.add_subparsers(dest="command", help="Command")

    # Register
    p_register = subparsers.add_parser("register", help="Register new identity")
    p_register.add_argument("--platform", "-p", required=True, help="Platform name")
    p_register.add_argument("--username", "-u", required=True, help="Username on platform")
    p_register.add_argument("--save", "-s", action="store_true", help="Save credentials to ~/.aip/")

    # Verify
    p_verify = subparsers.add_parser("verify", help="Verify identity")
    p_verify.add_argument("--did", "-d", help="DID to verify")
    p_verify.add_argument("--platform", "-p", help="Platform name")
    p_verify.add_argument("--username", "-u", help="Username on platform")

    # Lookup
    p_lookup = subparsers.add_parser("lookup", help="Look up agent by platform identity")
    p_lookup.add_argument("--platform", "-p", required=True, help="Platform name")
    p_lookup.add_argument("--username", "-u", required=True, help="Username")

    # Trust graph
    p_trust = subparsers.add_parser("trust-graph", help="Get trust relationships")
    p_trust.add_argument("--did", "-d", required=True, help="DID to look up")

    # Trust path
    p_path = subparsers.add_parser("trust-path", help="Check trust path between DIDs")
    p_path.add_argument("--source", "-s", required=True, help="Source DID")
    p_path.add_argument("--target", "-t", required=True, help="Target DID")
    p_path.add_argument("--scope", help="Trust scope filter")

    # Stats
    subparsers.add_parser("stats", help="Get service statistics")

    # Health
    subparsers.add_parser("health", help="Check service health")

    # Whoami
    subparsers.add_parser("whoami", help="Show current identity")

    # Trust (quick lookup)
    p_trust_quick = subparsers.add_parser("trust", help="Quick trust status lookup")
    p_trust_quick.add_argument("did", help="DID to look up")

    # Badge
    p_badge = subparsers.add_parser("badge", help="Get badge URL for a DID")
    p_badge.add_argument("did", help="DID to get badge for")
    p_badge.add_argument("--size", "-s", choices=["small", "medium", "large"], help="Badge size")
    p_badge.add_argument("--markdown", "-m", action="store_true", help="Output as markdown")
    p_badge.add_argument("--html", action="store_true", help="Output as HTML")

    # Vouch
    p_vouch = subparsers.add_parser("vouch", help="Create a trust vouch for another agent")
    p_vouch.add_argument("target", help="Target DID to vouch for")
    p_vouch.add_argument("--scope", "-c", default="GENERAL",
                         choices=["GENERAL", "CODE_SIGNING", "CODE_EXECUTION", "DATA_ACCESS", "FINANCIAL"],
                         help="Trust scope (default: GENERAL)")
    p_vouch.add_argument("--statement", "-m", help="Optional trust statement")
    p_vouch.add_argument("--ttl", "-t", type=int, help="Time-to-live in days (1-365)")

    # Skill sign
    p_skill_sign = subparsers.add_parser("skill-sign", help="Sign a skill file")
    p_skill_sign.add_argument("file", help="Path to skill.md file")
    p_skill_sign.add_argument("--output", "-o", help="Output file (default: overwrite input)")
    p_skill_sign.add_argument("--force", "-f", action="store_true", help="Replace existing signature")

    # Skill verify
    p_skill_verify = subparsers.add_parser("skill-verify", help="Verify a signed skill file")
    p_skill_verify.add_argument("file", help="Path to signed skill.md file")

    args = parser.parse_args()

    if args.command == "register":
        cmd_register(args)
    elif args.command == "verify":
        if not args.did and not (args.platform and args.username):
            parser.error("Either --did or both --platform and --username required")
        cmd_verify(args)
    elif args.command == "lookup":
        cmd_lookup(args)
    elif args.command == "trust-graph":
        cmd_trust_graph(args)
    elif args.command == "trust-path":
        cmd_trust_path(args)
    elif args.command == "stats":
        cmd_stats(args)
    elif args.command == "health":
        cmd_health(args)
    elif args.command == "whoami":
        cmd_whoami(args)
    elif args.command == "trust":
        cmd_trust(args)
    elif args.command == "badge":
        cmd_badge(args)
    elif args.command == "vouch":
        cmd_vouch(args)
    elif args.command == "skill-sign":
        cmd_skill_sign(args)
    elif args.command == "skill-verify":
        cmd_skill_verify(args)
    else:
        parser.print_help()


if __name__ == "__main__":
    main()
